% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/assert_return.R, R/print.R
\name{assert_return}
\alias{assert_return}
\alias{\%assert\%}
\alias{print.asserted_function}
\title{Assert Function Return Value}
\usage{
assert_return(func, expected_obj)

func \%assert\% expected_obj

\method{print}{asserted_function}(x, ..., wrapper = FALSE)
}
\arguments{
\item{func}{Function to wrap}

\item{expected_obj}{The expected return value.
Can be an expression evaluated (lazily) to an R object}

\item{x}{An \code{asserted_function} object}

\item{...}{Passed to \code{\link[base:print]{base::print.function()}}}

\item{wrapper}{Logical. If \code{TRUE}, prints the wrapper
instead of the original function}
}
\value{
A function of class "asserted_function"
}
\description{
\code{assert_return} returns a function that checks the return value
every time it runs.
This can be useful for debugging, or for general safety when you
want to make sure a function returns a specific kind of object.
}
\details{
The functions generates an \code{asserted_function} object, which inherits
from the regular \code{function} class. The original function is bound
to the environment of returned \code{asserted_function}. So to access the
original function you could use \verb{[base::environment()]}. To pass
anonymous functions to \verb{\%assert\%}, you need to surround \code{func} in round
brackets (see examples).
}
\examples{
f <- (function(x, char = FALSE) {
        if (char)
                return(as.character(x ^ 2 - x))

        x ^ 2 - x
}) \%assert\% numeric()

f(1:10)
\dontrun{
f(1:10, char = TRUE)
#Error in f(1:10, char = TRUE) :
#  Return value is `character`. Expecting `numeric`
}

sum2 <- assert_return(sum, integer())
sum2(1:10)
\dontrun{
sum2(c(0.5, 1, 1.5))
#Error in sum2(c(0.5, 1, 1.5)) :
#  Return value is `numeric`. Expecting `integer`
}

print(f)
print(sum2)
}
\author{
Erez Shomron
}
